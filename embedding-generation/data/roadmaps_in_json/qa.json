{
    "fileName": "qa",
    "name": "qa",
    "type": "directory",
    "children": [
        {
            "id": "100",
            "fileName": "qa-basics",
            "name": "qa basics",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "what-is-qa.md",
                    "name": "what is qa",
                    "type": "file",
                    "content": "\nQuality is extremely hard to define, and it is simply stated: “Fit for use or purpose.” It is all about meeting the needs and expectations of customers concerning the functionality, design, reliability, durability, & price of the product.\n\n## What is Assurance\n\nAssurance is nothing but a positive declaration of a product or service, which gives confidence. It is certain of a product or a service which it will work well. It provides a guarantee that the product will work without any problems as per the expectations or requirements.\n\n## Quality Assurance in Software Testing\n\nQuality Assurance in Software Testing is defined as a procedure to ensure the quality of software products or services provided to the customers by an organization. Quality assurance focuses on improving the [software development process](https://www.guru99.com/software-development-life-cycle-tutorial.html) and making it efficient and effective per the quality standards defined for software products. Quality Assurance is popularly known as QA Testing.\n\nVisit the following resources to learn more:\n\n- [What is Quality Assurance(QA)? Process, Methods, Examples](https://www.guru99.com/all-about-quality-assurance.html)\n- [What Do Software Testers Do?](https://www.ministryoftesting.com/dojo/lessons/what-do-software-testers-do-version-0-1)\n"
                },
                {
                    "id": "101",
                    "fileName": "tester-mindset.md",
                    "name": "tester mindset",
                    "type": "file",
                    "content": "\nAs a Quality Assurance Engineer, your job is to look for the weak spots in a product, whatever that product may be, and report them back, so that they can be fixed and thus, the product you are working on can be of the highest quality possible.\n\nTo do your job successfully, you need to have a Testing mindset. What does that mean? Among other things, it means you have to think in the most destructive way possible and be as creative as possible.\n\nA few important points:\n\n- Know the product you are testing\n- Don’t be afraid to think outside of the box when you are testing it\n- Don’t be afraid to misuse it as much as possible.\n\nVisit the following resources to learn more:\n\n- [The Software Tester’s Mindset](https://softwaretester.careers/the-software-testers-mindset/)\n- [How to Think Like a Tester](https://medium.com/@blakenorrish/how-to-think-like-a-tester-7a174ff6aeaf)\n"
                },
                {
                    "id": "102",
                    "fileName": "testing-approaches",
                    "name": "testing approaches",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "white-box-testing.md",
                            "name": "white box testing",
                            "type": "file",
                            "content": "\nWhite Box Testing is a technique in which software’s internal structure, design, and coding are tested to verify input-output flow and improve design, usability, and security. In white box testing, code is visible to testers, so it is also called Clear box testing, Open box testing, Transparent box testing, Code-based testing, and Glass box testing.\n\nVisit the following resources to learn more:\n\n- [White Box Testing – What is, Techniques, Example & Types](https://www.guru99.com/white-box-testing.html)\n- [A Complete Guide With Techniques, Examples, & Tools](https://www.softwaretestinghelp.com/white-box-testing-techniques-with-example/)\n"
                        },
                        {
                            "id": "101",
                            "fileName": "gray-box-testing.md",
                            "name": "gray box testing",
                            "type": "file",
                            "content": "\nGray box testing is a software testing technique to test a software product or application with partial knowledge of the internal structure of the application. The purpose of gray box testing is to search and identify the defects due to improper code structure or improper use of applications.\n\nVisit the following resources to learn more:\n\n- [What is Gray Box Testing? Techniques & Example](https://www.guru99.com/grey-box-testing.html)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "black-box-testing.md",
                            "name": "black box testing",
                            "type": "file",
                            "content": "\nBlack Box Testing is a software testing method in which the functionalities of software applications are tested without having knowledge of internal code structure, implementation details and internal paths. Black Box Testing mainly focuses on input and output of software applications and it is entirely based on software requirements and specifications. It is also known as Behavioral Testing.\n\nVisit the following resources to learn more:\n\n- [What is BLACK Box Testing? Techniques, Example & Types](https://www.guru99.com/black-box-testing.html)\n- [Black Box Testing: An In-Depth Tutorial With Examples And Techniques](https://www.softwaretestinghelp.com/black-box-testing/)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nTest approach has two techniques:\nProactive - An approach in which the test design process is initiated as early as possible in order to find and fix the defects before the build is created.\nReactive - An approach in which the testing is not started until after design and coding are completed.\n\nThree approaches are commonly used to implement functional testing:\n\n- Black Box Testing\n- White Box Testing\n- Gray Box Testing\n\nVisit the following resources to learn more:\n\n- [Functional Testing Approaches and Agile Considerations](https://www.qualitylogic.com/knowledge-center/functional-testing-approaches-agile-considerations/)\n"
                        }
                    ]
                },
                {
                    "id": "103",
                    "fileName": "test-oracles.md",
                    "name": "test oracles",
                    "type": "file",
                    "content": "\nA test oracle is a mechanism; different from the program itself that can be used to check the correctness of the program's output for the test cases. Conceptually, we can consider testing a process in which the test cases are given to the test oracle and the program under testing.\n\nVisit the following resources to learn more:\n\n- [What are Test Oracles](https://ecomputernotes.com/software-engineering/what-are-test-oracles)\n"
                },
                {
                    "id": "104",
                    "fileName": "test-prioritization.md",
                    "name": "test prioritization",
                    "type": "file",
                    "content": "\nTest prioritization is ordering the test cases to be conducted eventually. Prioritizing test cases aids to meet two important constraints, namely time and budget in software testing to enhance the fault detection rate as early as possible.\n\nVisit the following resources to learn more:\n\n- [A Tour of what is Test Prioritization?](https://www.browserstack.com/guide/test-case-prioritization)\n- [Test Prioritization](https://www.professionalqa.com/test-prioritization)\n- [Learn about Test Prioritization](https://www.geeksforgeeks.org/test-case-prioritization-in-software-testing/)\n- [Test Prioritization fundamentals!](https://testomat.io/features/test-case-priorities/)\n"
                },
                {
                    "id": "105",
                    "fileName": "manage-your-testing",
                    "name": "manage your testing",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "qtest.md",
                            "name": "qtest",
                            "type": "file",
                            "content": "\nqTest is a test management tool used for Project Management, Bug Tracking, and Test Management. It follows the centralized test management concept that helps to communicate easily and assists in rapid development of task across QA team and other stakeholders.\n\nVisit the following resources to learn more:\n\n- [QTest tutorial](https://www.tutorialspoint.com/qtest/qtest_introduction.htm)\n- [Getting Started with qTest and Parameters](https://www.youtube.com/watch?v=1q8vQ2XF9QE)\n"
                        },
                        {
                            "id": "101",
                            "fileName": "test-rail.md",
                            "name": "test rail",
                            "type": "file",
                            "content": "\nTestRail is a web-based test case management tool. It is used by testers, developers and team leads to manage, track, and organize software testing efforts. TestRail allows team members to enter test cases, organize test suites, execute test runs, and track their results, all from a modern and easy to use web interface.\n\nVisit the following resources to learn more:\n\n- [TestRail Website](https://www.gurock.com/testrail/)\n- [TestRail Review Tutorial: Learn End-To-End Test Case Management](https://www.softwaretestinghelp.com/testrail-tutorial/)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "test-link.md",
                            "name": "test link",
                            "type": "file",
                            "content": "\nTestLink is most widely used web based open source test management tool. It synchronizes both requirements specification and test specification together. Tester can create test project and document test cases using this tool. With TestLink you can create an account for multiple users and assign different user roles.\n\nVisit the following resources to learn more:\n\n- [TestLink Website](https://testlink.org/)\n- [TestLink Tutorial: A Complete Guide](https://www.guru99.com/testlink-tutorial-complete-guide.html)\n"
                        },
                        {
                            "id": "103",
                            "fileName": "zephyr.md",
                            "name": "zephyr",
                            "type": "file",
                            "content": "\nZephyr is a testing solution that improves the quality of your software by managing and monitoring end-to-end testing. It is very effective for managing manual testing. Its key capabilities include:\n\n- Test-case creation\n- Organization of tests by product releases and components\n- Assignment of tests to the Quality Assurance team\n\nVisit the following resources to learn more:\n\n- [Zephyr for JIRA Tutorial: Test Management Tool](https://www.guru99.com/zephyr-agile-jira.html)\n"
                        },
                        {
                            "id": "106",
                            "fileName": "xray.md",
                            "name": "xray",
                            "type": "file",
                            "content": "\nXray is a complete Test Management tool for Jira. It is a full-featured app that does not require any other software in order to run.\nXray supports the entire testing life cycle: test planning, test design, test execution and test reporting. Xray does this by using special Jira issue types, so you can use all Jira benefits that you are used to.\nJira's aim is to help you improve the quality of your systems through effective and efficient testing. That's why from its first version, Xray already supports both manual and automated tests, including full support for BDD framework (e.g. Cucumber, SpecFlow, Serenity BDD) examples/tests in the native language (i.e., English).\n\nVisit the following resources to learn more:\n\n- [xRay - Getting Started](https://docs.getxray.app/display/XRAY/Getting+started)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nTest Management is a process of managing the testing activities in order to ensure high quality and high-end testing of the software application. The method consists of organizing, controlling, ensuring traceability and visibility of the testing process in order to deliver the high quality software application. It ensures that the software testing process runs as expected.\n\nVisit the following resources to learn more:\n\n- [Test Management Process in Software Testing](https://www.guru99.com/test-management-phases-a-complete-guide-for-testing-project.html)\n"
                        }
                    ]
                },
                {
                    "id": "106",
                    "fileName": "project-management",
                    "name": "project management",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "atlassian.md",
                            "name": "atlassian",
                            "type": "file",
                            "content": "\nJira is a software application used for issue tracking and project management. The tool, developed by the Australian software company Atlassian, has become widely used by agile development teams to track bugs, stories, epics, and other tasks.\n\nVisit the following resources to learn more:\n\n- [Atlassian Website](https://www.atlassian.com/)\n- [What is Jira used for?](https://www.atlassian.com/software/jira/guides/use-cases/what-is-jira-used-for#glossary-of-items)\n- [What is Jira?](https://www.simplilearn.com/tutorials/jira/what-is-jira-and-how-to-use-jira-testing-software)\n- [JIRA Tutorial: A Complete Hands-On How-To-Use JIRA Guide](https://www.softwaretestinghelp.com/atlassian-jira-tutorial-1/)"
                        },
                        {
                            "id": "101",
                            "fileName": "assembla.md",
                            "name": "assembla",
                            "type": "file",
                            "content": "\nAssembla is an extensive suite of applications for software development, enabling distributed agile teams. It allows development teams to manage, initiate and maintain agile projects, applications and websites.\n\nVisit the following resources to learn more:\n\n- [Assembla Website](https://get.assembla.com/projects/)\n- [What is Assembla?](https://www.selecthub.com/project-management-software/assembla)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "youtrack.md",
                            "name": "youtrack",
                            "type": "file",
                            "content": "\nYouTrack is a project management software developed by JetBrains. It’s in the form of a plugin that can be attached to the JetBrains IDEs such as Intellij Idea, and helps create and assign tasks to a development team as well as track the progress of working.\n\nVisit the following resources to learn more:\n\n- [YouTrack Website](https://www.jetbrains.com/youtrack/)\n- [YouTrack for Beginners](https://medium.com/nerd-for-tech/youtrack-for-beginners-31e1e156fdd0)\n"
                        },
                        {
                            "id": "103",
                            "fileName": "trello.md",
                            "name": "trello",
                            "type": "file",
                            "content": "\nTrello is a popular, simple, and easy-to-use collaboration tool that enables you to organize projects and everything related to them into boards. With Trello, you can find all kinds of information, such as:\n\n- What’s being worked on?\n- Who’s working on what?\n- What progress the project is making\n\nVisit the following resources to learn more:\n\n- [Trello Website](https://trello.com/en)\n- [What is Trello and How To Use It?](https://www.simplilearn.com/tutorials/project-management-tutorial/what-is-trello)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nA project is a temporary endeavor to create a unique product, service, or result. A project is temporary because it has a defined beginning and end time, and it is unique because it has a particular set of operations designed to accomplish a goal.\n\nProject Management is a discipline of planning, organizing, motivating, and controlling the resources to achieve specific project goals. The main objective of project management is to achieve project goals and targets while keeping in mind the project scope, time, quality, and cost. It facilitates the project workflow with team collaboration on a single project.\n\nVisit the following resources to learn more:\n\n- [What are the Main Objectives of Project Management?](https://www.guru99.com/introduction-project-management-pmp-certification.html)\n- [Project Management in Software Testing](https://huddle.eurostarsoftwaretesting.com/project-management-in-software-testing/)\n- [Project Management Life Cycle Phases: What are the stages?](https://www.guru99.com/initiation-phase-project-management-life-cycle.html)\n"
                        }
                    ]
                },
                {
                    "id": "107",
                    "fileName": "testing-techniques",
                    "name": "testing techniques",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "functional-testing",
                            "name": "functional testing",
                            "type": "directory",
                            "children": [
                                {
                                    "id": "100",
                                    "fileName": "uat.md",
                                    "name": "uat",
                                    "type": "file",
                                    "content": "\nUser Acceptance Testing (UAT) is a type of testing performed by the end user or the client to verify/accept the software system before moving the software application to the production environment. UAT is done in the final phase of testing after functional, integration and system testing is done.\n\nVisit the following resources to learn more:\n\n- [What is User Acceptance Testing (UAT)?](https://www.guru99.com/user-acceptance-testing.html)\n- [How to plan your UAT](https://www.youtube.com/watch?v=AU8SV7091-s)\n"
                                },
                                {
                                    "id": "101",
                                    "fileName": "exploratory-testing.md",
                                    "name": "exploratory testing",
                                    "type": "file",
                                    "content": "\nExploratory testing is evaluating a product by learning about it through exploration and experimentation, including to some degree: questioning, study, modeling, observation, inference, etc.\n\nVisit the following resources to learn more:\n\n- [Exploratory Testing](https://www.satisfice.com/exploratory-testing)\n- [Exploratory Testing 3.0](https://www.satisfice.com/blog/archives/1509)\n- [History of Definitions of Exploratory Testing](https://www.satisfice.com/blog/archives/1504)\n"
                                },
                                {
                                    "id": "102",
                                    "fileName": "sanity-testing.md",
                                    "name": "sanity testing",
                                    "type": "file",
                                    "content": "\nSanity testing is a kind of Software Testing performed after receiving a software build, with minor changes in code, or functionality, to ascertain that the bugs have been fixed and no further issues are introduced due to these changes. The goal is to determine that the proposed functionality works roughly as expected. If sanity test fails, the build is rejected to save the time and costs involved in a more rigorous testing.\n\nVisit the following resources to learn more:\n\n- [Sanity Testing | Software Testing](https://www.geeksforgeeks.org/sanity-testing-software-testing/)\n"
                                },
                                {
                                    "id": "103",
                                    "fileName": "regression-testing.md",
                                    "name": "regression testing",
                                    "type": "file",
                                    "content": "\nRegression Testing is a type of software testing to confirm that a recent program or code change has not adversely affected existing features. Regression testing is a black box testing technique. Test cases are re-executed to check the previous functionality of the application is working fine and that the new changes have not produced any bugs.\n\nVisit the following resources to learn more:\n\n- [Regression Testing](https://www.javatpoint.com/regression-testing)\n- [What is Regression Testing with Test Cases](https://www.guru99.com/regression-testing.html)\n"
                                },
                                {
                                    "id": "104",
                                    "fileName": "smoke-testing.md",
                                    "name": "smoke testing",
                                    "type": "file",
                                    "content": "\nSmoke Testing is a software testing process that determines whether the deployed software build is stable or not. Smoke testing is a confirmation for QA team to proceed with further software testing. It consists of a minimal set of tests run on each build to test software functionalities.\n\nVisit the following resources to learn more:\n\n- [Smoke Testing | Software Testing](https://www.guru99.com/smoke-testing.html)\n"
                                },
                                {
                                    "id": "105",
                                    "fileName": "unit-testing.md",
                                    "name": "unit testing",
                                    "type": "file",
                                    "content": "\nUnit testing is where individual **units** (modules, functions/methods, routines, etc.) of software are tested to ensure their correctness. This low-level testing ensures smaller components are functionally sound while taking the burden off of higher-level tests. Generally, a developer writes these tests during the development process and they are run as automated tests.\n\nVisit the following resources to learn more:\n\n- [Unit Testing Tutorial](https://www.guru99.com/unit-testing-guide.html)\n- [What is Unit Testing?](https://youtu.be/3kzHmaeozDI)\n"
                                },
                                {
                                    "id": "106",
                                    "fileName": "integration-testing.md",
                                    "name": "integration testing",
                                    "type": "file",
                                    "content": "\nIntegration Testing is a type of testing where software modules are integrated logically and tested as a group. A typical software project consists of multiple software modules coded by different programmers. This testing level aims to expose defects in the interaction between these software modules when they are integrated. Integration Testing focuses on checking data communication amongst these modules.\n\nVisit the following resources to learn more:\n\n- [Integration Testing Tutorial](https://www.guru99.com/integration-testing.html)\n"
                                },
                                {
                                    "fileName": "index.md",
                                    "name": "index",
                                    "type": "file",
                                    "content": "\nFunctional testing is a type of software testing that validates the software system against the functional requirements/specifications. The purpose of Functional tests is to test each function of the software application by providing appropriate input and verifying the output against the Functional requirements.\n\nVisit the following resources to learn more:\n\n- [What is Functional Testing? Types & Examples](https://www.guru99.com/functional-testing.html)\n- [Functional Testing : A Detailed Guide](https://www.browserstack.com/guide/functional-testing)\n"
                                }
                            ]
                        },
                        {
                            "id": "101",
                            "fileName": "non-functional-testing",
                            "name": "non functional testing",
                            "type": "directory",
                            "children": [
                                {
                                    "id": "100",
                                    "fileName": "load-testing.md",
                                    "name": "load testing",
                                    "type": "file",
                                    "content": "\nLoad Testing is a type of Performance Testing that determines the performance of a system, software product, or software application under real-life-based load conditions. Load testing determines the behavior of the application when multiple users use it at the same time. It is the response of the system measured under varying load conditions.\n\nVisit the following resources to learn more:\n\n- [Software Testing: Load Testing](https://www.geeksforgeeks.org/software-testing-load-testing/)\n- [Load testing and Best Practices](https://loadninja.com/load-testing/)\n"
                                },
                                {
                                    "id": "101",
                                    "fileName": "performance-testing.md",
                                    "name": "performance testing",
                                    "type": "file",
                                    "content": "\nPerformance Testing is a subset of Performance Engineering. It is a process of evaluating a system’s behavior under various extreme conditions. The main intent of performance testing is monitoring and improving key performance indicators such as response time, throughput, memory, CPU utilization, and more.\n\nThere are three objectives (three S) of Performance testing to observe and evaluate: `Speed`, `Scalability`, and `Stability`.\n\n## Types of Performance Testing\n\nFollowing are the commonly used performance testing types, but not limited to:\n\n- Load Testing\n- Stress Testing\n- Spike Testing\n- Endurance Testing\n- Volume Testing\n- Scalability Testing\n- Capacity Testing\n\nVisit the following resources to learn more:\n\n- [Performance Testing Tutorial – Types (Example)](https://www.guru99.com/performance-testing.html)\n"
                                },
                                {
                                    "id": "102",
                                    "fileName": "stress-testing.md",
                                    "name": "stress testing",
                                    "type": "file",
                                    "content": "\n`Stress Testing` is a type of `Performance Testing`. The objective of stress testing is to identify the breaking point of application under test under extreme normal load.\n\ne.g. Injecting high volume of requests per second to an API might cause the disruption to its service, or throws HTTP 503 Service Unavailable or cause other consequences.\n\nVisit the following resources to learn more:\n\n- [What is Stress Testing in Software Testing?](https://www.guru99.com/stress-testing-tutorial.html)\n"
                                },
                                {
                                    "id": "103",
                                    "fileName": "security-testing.md",
                                    "name": "security testing",
                                    "type": "file",
                                    "content": "\nSecurity Testing is a type of Software Testing that uncovers vulnerabilities, threats, or risks in a software application and prevents malicious attacks from intruders. The purpose of Security Tests is to identify all possible loopholes and weaknesses of the software system which might result in a loss of information, revenue, repute at the hands of the employees or outsiders of the organization.\n\nVisit the following resources to learn more:\n\n- [What is Security Testing? Types with Example](https://www.guru99.com/what-is-security-testing.html)\n- [Security Testing: Types, Tools, and Best Practices](https://brightsec.com/blog/security-testing/)\n"
                                },
                                {
                                    "id": "104",
                                    "fileName": "accessibility-testing.md",
                                    "name": "accessibility testing",
                                    "type": "file",
                                    "content": "\nAccessibility Testing is defined as a type of Software Testing performed to ensure that the application being tested is usable by people with disabilities like hearing, color blindness, old age, low vision and other disadvantaged groups.\n\nVisit the following resources to learn more:\n\n- [What is Accessibility Testing? (Examples)](https://www.guru99.com/accessibility-testing.html)\n- [Accessibility Testing Tutorial (Step By Step Guide)](https://www.softwaretestinghelp.com/what-is-web-accessibility-testing/)\n- [IBM Accessibility Toolkit](https://www.ibm.com/able/)\n"
                                },
                                {
                                    "fileName": "index.md",
                                    "name": "index",
                                    "type": "file",
                                    "content": "\nNon-functional testing is a type of software testing to test non-functional parameters such as reliability, load test, performance, and accountability of the software. The primary purpose of non-functional testing is to test the reading speed of the software system as per non-functional parameters. The parameters of non-functional testing are never tested before the functional testing.\n\nVisit the following resources to learn more:\n\n- [What is Non Functional Testing](https://www.browserstack.com/guide/what-is-non-functional-testing)\n- [Types of Non Functional Testing](https://www.guru99.com/non-functional-testing.html)\n"
                                }
                            ]
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nTesting Techniques are methods applied to evaluate a system or a component with a purpose to find if it satisfies the given requirements. Testing of a system helps to identify gaps, errors, or any kind of missing requirements differing from the actual requirements. These techniques ensure the overall quality of the product or software including performance, security, customer experience, and so on.\n\nVisit the following resources to learn more:\n\n- [What are Testing Techniques : Types, Advantages & Disadvantages](https://www.elprocus.com/what-are-testing-techniques-types-advantages-disadvantages/)\n"
                        }
                    ]
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nThe phrase \"fit for use or purpose\" sums up quality, which is incredibly difficult to define. It all comes down to fulfilling the requirements and expectations of the consumer in terms of the product's usefulness, design, dependability, durability, and price.\n\nAssurance is nothing more than a confident statement made about a good or service. It is the assurance that a good outcome is guaranteed for a good or service. It offers a warranty that the product will perform faultlessly in accordance with expectations or needs.\n\nQuality Assurance (QA) also known as QA testing is an activity to ensure that an organization provides the best product or service to the customers. QA testing of a software involves the testing of performance, adaptability, and functionality. Yet, software quality assurance extends beyond software quality; it also comprises the quality process used for developing, testing, and release of software products. QA relies on the software development cycle, which includes the management of software requirements, design, coding, testing, and release.\n"
                }
            ]
        },
        {
            "id": "101",
            "fileName": "qa-sdlc",
            "name": "qa sdlc",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "waterfall-model.md",
                    "name": "waterfall model",
                    "type": "file",
                    "content": "\nWaterfall Model is a sequential model that divides software development into pre-defined phases. Each phase must be completed before the next phase can begin with no overlap between the phases. Each phase is designed for performing specific activity during the SDLC phase.\n\nVisit the following resources to learn more:\n\n- [What is Waterfall Model in SDLC? Advantages and Disadvantages](https://www.guru99.com/what-is-sdlc-or-waterfall-model.html)\n"
                },
                {
                    "id": "101",
                    "fileName": "v-model.md",
                    "name": "v model",
                    "type": "file",
                    "content": "\nV Model is a highly disciplined SDLC model that has a testing phase parallel to each development phase. The V model is an extension of the waterfall model wherein software development and testing is executed in a sequential way. It's also known as the Validation or Verification Model.\n\nVisit the following resources to learn more:\n\n- [V-Model in Software Testing](https://www.guru99.com/v-model-software-testing.html)\n- [SDLC V-Model](https://www.geeksforgeeks.org/software-engineering-sdlc-v-model/)\n"
                },
                {
                    "id": "102",
                    "fileName": "agile-model",
                    "name": "agile model",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "kanban.md",
                            "name": "kanban",
                            "type": "file",
                            "content": "\nKanban is a very popular framework for development in the agile software development methodology. It provides a transparent way of visualizing the tasks and work capacity of a team. It mainly uses physical and digital boards to allow the team members to visualize the current state of the project they are working on.\n\nA kanban board is an agile project management tool designed to help visualize work, limit work-in-progress, and maximize efficiency.\n\nVisit the following resources to learn more:\n\n- [Kanban - A brief introduction](https://www.atlassian.com/agile/kanban)\n- [Kanban Model in Software Engineering](https://www.guru99.com/kanban-cards-boards-methodology.html)\n"
                        },
                        {
                            "id": "101",
                            "fileName": "scrum.md",
                            "name": "scrum",
                            "type": "file",
                            "content": "\nScrum in Software Testing is a methodology for building complex software applications. It provides easy solutions for executing complicated tasks. Scrum helps the development team to focus on all aspects of the software product development like quality, performance, usability, and so on. It provides with transparency, inspection and adaptation during the software development to avoid complexity.\n\nVisit the following resources to learn more:\n\n- [Scrum Testing Methodology Tutorial](https://www.guru99.com/scrum-testing-beginner-guide.html)\n- [Scrum - What is, How it works](https://www.atlassian.com/agile/scrum)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "safe.md",
                            "name": "safe",
                            "type": "file",
                            "content": "\nScaled Agile Framework (SAFe) is a freely available online knowledge base that allows you to apply lean-agile practices at the enterprise level. It provides a simple and lightweight experience for software development. It is a set of organizations and workflow patterns intended to guide enterprises for scaling lean and agile practices. It is divided into three segments which are Team, Program and Portfolio.\n\nVisit the following resources to learn more:\n\n- [SAFe (Scaled Agile Framework) Tutorial](https://www.guru99.com/scaled-agile-framework.html)\n"
                        },
                        {
                            "id": "103",
                            "fileName": "xp.md",
                            "name": "xp",
                            "type": "file",
                            "content": "\nExtreme Programming (XP) is an agile software development framework that aims to produce higher quality software, and higher quality of life for the development team. XP is the most specific of the agile frameworks regarding appropriate engineering practices for software development.\n\nVisit the following resources to learn more:\n\n- [What is Extreme Programming (XP)?](https://www.agilealliance.org/glossary/xp)\n- [Software Engineering | Extreme Programming (XP)](https://www.geeksforgeeks.org/software-engineering-extreme-programming-xp/)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nThe agile model refers to a software development approach based on iterative development. Agile methods break tasks into smaller iterations or parts that do not directly involve long-term planning. The project scope and requirements are laid down at the beginning of the development process. Plans regarding the number of iterations, the duration, and the scope of each iteration are clearly defined in advance.\n\nThe Agile software development methodology is one of the simplest and most effective processes to turn a vision for a business need into software solutions.\n\nVisit the following resources to learn more:\n\n- [Agile Methodology: What is Agile Model in Software Testing?](https://www.guru99.com/agile-scrum-extreme-testing.html)\n- [Agile Model](https://www.javatpoint.com/software-engineering-agile-model)\n- [Manifesto for Agile Software Development](https://agilemanifesto.org/)\n"
                        }
                    ]
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nThe Software Development Life Cycle (SDLC) is a process followed for a software project, within a software organization. It consists of a detailed plan describing how to develop, maintain, replace and alter or enhance specific software. The life cycle defines a methodology for improving the quality of software and the overall development process.\n\nVisit the following resources to learn more:\n\n- [QA Role In SDLC: Why Is Quality Assurance Important In IT](https://cadabra.studio/blog/why-is-quality-assurance-important-qa-role-in-sdlc/)\n- [SDLC Overview](https://www.tutorialspoint.com/sdlc/sdlc_overview.htm)\n"
                }
            ]
        },
        {
            "id": "102",
            "fileName": "qa-manual-testing",
            "name": "qa manual testing",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "tdd.md",
                    "name": "tdd",
                    "type": "file",
                    "content": "\nTest Driven Development (TDD) is software development approach in which test cases are developed to specify and validate what the code will do. In simple terms, test cases for each functionality are created and tested first and if the test fails then the new code is written in order to pass the test and making code simple and bug-free.\n\nVisit the following resources to learn more:\n\n- [What is Test Driven Development (TDD)? Tutorial with Example](https://www.guru99.com/test-driven-development.html)\n- [Introduction to Test Driven Development (TDD)](https://pt.coursera.org/learn/test-and-behavior-driven-development-tdd-bdd)\n"
                },
                {
                    "id": "101",
                    "fileName": "test-planning.md",
                    "name": "test planning",
                    "type": "file",
                    "content": "\nA Test Plan is a detailed document that describes the test strategy, objectives, schedule, estimation, deliverables, and resources required to perform testing for a software product. Test Plan helps us determine the effort needed to validate the quality of the application under test.\n\nVisit the following resources to learn more:\n\n- [Test Plan: What is, How to Create (with Example)](https://www.guru99.com/what-everybody-ought-to-know-about-test-planing.html)\n"
                },
                {
                    "id": "102",
                    "fileName": "test-cases-and-scenarios.md",
                    "name": "test cases and scenarios",
                    "type": "file",
                    "content": "\nA Test Case is a set of actions executed to verify a particular feature or functionality of your software application. A Test Case contains test steps, test data, precondition, and postcondition developed for a specific test scenario to verify any requirement. The test case includes specific variables or conditions, using which a testing engineer can compare expected and actual results to determine whether a software product is functioning as per the requirements of the customer.\n\nA Test Scenario is defined as any functionality that can be tested. It is a collective set of test cases which helps the testing team to determine the positive and negative characteristics of the project.\n\nVisit the following resources to learn more:\n\n- [Test Case vs Test Scenario – Difference Between Them](https://www.guru99.com/test-case-vs-test-scenario.html)\n- [How to Write Test Cases in Software Testing with Examples](https://www.guru99.com/test-case.html)\n"
                },
                {
                    "id": "103",
                    "fileName": "reporting.md",
                    "name": "reporting",
                    "type": "file",
                    "content": "\nCommunicating the QA and testing team outputs can be interpreted in several different ways. Having a solid reporting stream is very essential for all the decisions that a stakeholder/manager can take.\n\nVisit the following resources to learn more:\n\n- [Defect Management Process in Software Testing](https://www.guru99.com/defect-management-process.html)\n- [Writing clear bug reports](https://automationhacks.io/2020/07/25/writing-clear-bug-reports/)\n- [The Art Of The Bug Report](https://www.ministryoftesting.com/articles/11b82aee?s_id=15465627)\n"
                },
                {
                    "id": "104",
                    "fileName": "compatibility.md",
                    "name": "compatibility",
                    "type": "file",
                    "content": "\nCompatibility is nothing but the capability of existing or living together. Compatibility Testing is a type of Software testing to check whether your software is capable of running on different hardware, operating systems, applications, network environments or Mobile devices.\n\nVisit the following resources to learn more:\n\n- [What is Compatibility Testing? Forward & Backward Example](https://www.guru99.com/compatibility-testing.html)\n"
                },
                {
                    "id": "105",
                    "fileName": "verification-and-validation.md",
                    "name": "verification and validation",
                    "type": "file",
                    "content": "\nVerification in Software Testing is a process of checking documents, design, code, and program in order to check if the software has been built according to the requirements or not. The main goal of verification process is to ensure quality of software application, design, architecture etc. The verification process involves activities like reviews, walk-throughs and inspection.\n\nValidation in Software Engineering is a dynamic mechanism of testing and validating if the software product actually meets the exact needs of the customer or not. The process helps to ensure that the software fulfills the desired use in an appropriate environment. The validation process involves activities like unit testing, integration testing, system testing and user acceptance testing.\n\nVisit the following resources to learn more:\n\n- [Differences Between Verification and Validation](https://www.guru99.com/verification-v-s-validation-in-a-software-testing.html)\n- [Design Verification & Validation Process](https://www.guru99.com/design-verification-process.html)\n"
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nManual Testing is a type of software testing in which test cases are executed manually by a tester without using any automated tools. The purpose of Manual Testing is to identify the bugs, issues, and defects in the software application. Manual software testing is the most primitive technique of all testing types and it helps to find critical bugs in the software application.\n\nVisit the following resources to learn more:\n\n- [Manual Testing Tutorial: What is, Types, Concepts](https://www.guru99.com/manual-testing.html)\n- [Manual Testing](https://www.javatpoint.com/manual-testing)\n"
                }
            ]
        },
        {
            "id": "103",
            "fileName": "qa-automated-testing",
            "name": "qa automated testing",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "frontend-automation",
                    "name": "frontend automation",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "basic-introduction",
                            "name": "basic introduction",
                            "type": "directory",
                            "children": [
                                {
                                    "id": "100",
                                    "fileName": "html-css-javascript.md",
                                    "name": "html css javascript",
                                    "type": "file",
                                    "content": "\nHTML stands for HyperText Markup Language. It is used on the front and gives structure to the webpage, which you can style using CSS and make interactive using JavaScript.\n\nCSS or Cascading Style Sheets is the language used to style the front end of any website. CSS is a cornerstone technology of the World Wide Web, alongside HTML and JavaScript.\n\nJavaScript allows you to add interactivity to your pages. You may have seen common examples on the websites: sliders, click interactions, popups, and so on.\n\nVisit the following resources to learn more:\n\n- [W3Schools: Learn HTML](https://www.w3schools.com/html/html_intro.asp)\n- [W3Schools — Learn CSS](https://www.w3schools.com/css/)\n- [W3Schools – JavaScript Tutorial](https://www.w3schools.com/js/)\n"
                                },
                                {
                                    "id": "101",
                                    "fileName": "browser-devtools.md",
                                    "name": "browser devtools",
                                    "type": "file",
                                    "content": "\nEvery modern web browser includes a powerful suite of developer tools. These tools do a range of things, from inspecting currently-loaded HTML, CSS and JavaScript to showing which assets the page has requested and how long they took to load. This article explains how to use the basic functions of your browser's devtools.\n\nVisit the following resources to learn more:\n\n- [What are browser developer tools?](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools)\n- [Browser Developer Tools](https://www.geeksforgeeks.org/browser-developer-tools/)\n"
                                },
                                {
                                    "id": "102",
                                    "fileName": "ajax.md",
                                    "name": "ajax",
                                    "type": "file",
                                    "content": "\nAJAX stands for Asynchronous JavaScript And XML. In a nutshell, it is the use of the XMLHttpRequest object to communicate with servers. It can send and receive information in various formats, including JSON, XML, HTML, and text files.\n\nVisit the following resources to learn more:\n\n- [What is AJAX?](https://www.w3schools.com/whatis/whatis_ajax.asp)\n- [Getting started](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started)\n- [What Is Ajax?](https://www.youtube.com/watch?v=3l13qGLTgNw)\n"
                                },
                                {
                                    "id": "103",
                                    "fileName": "caching.md",
                                    "name": "caching",
                                    "type": "file",
                                    "content": "\nCaching ensures that the resources downloaded once are reused instead of doing a fresh fetch again. It is useful for increasing subsequent page load speed by reusing cached images, fonts, and other static assets. Caching should not be typically done on dynamic content. For example list of posts or comments. As part of the testing strategy, both caching and cache invalidation (not getting stale dynamic content) needs to be tested.\n\nVisit the following resources to learn more:\n\n- [Caching - Simply Explained](https://www.youtube.com/watch?v=6FyXURRVmR0)\n"
                                },
                                {
                                    "id": "104",
                                    "fileName": "swas-pwas-jamstack.md",
                                    "name": "swas pwas jamstack",
                                    "type": "file",
                                    "content": "\n## SWAs\n\nA Static Web Application is any web application that can be delivered directly to an end user's browser without any server-side alteration of the HTML, CSS, or JavaScript content. While this can encompass very flat, unchanging sites like a corporate web site, static web applications generally refer to rich sites that utilize technologies in the browser instead of on the server to deliver dynamic content.\n\n## PWAs\n\nAt their heart, Progressive Web Apps are just web applications. Using progressive enhancement, new capabilities are enabled in modern browsers. Using service workers and a web app manifest, your web application becomes reliable and installable. If the new capabilities aren't available, users still get the core experience.\n\nProgressive Web Apps provide you with a unique opportunity to deliver a web experience your users will love. Using the latest web features to bring enhanced capabilities and reliability, Progressive Web Apps allow what you build to be installed by anyone, anywhere, on any device with a single codebase.\n\n## Jamstack\n\nJamstack is an architectural approach that decouples the web experience layer from data and business logic, improving flexibility, scalability, performance, and maintainability.\nJamstack removes the need for business logic to dictate the web experience. It enables a composable architecture for the web where custom logic and 3rd party services are consumed through APIs.\n\nVisit the following resources to learn more:\n\n- [SWA](https://www.staticapps.org/)\n- [PWA](https://web.dev/progressive-web-apps/)\n- [Jamstack](https://jamstack.org/)\n"
                                },
                                {
                                    "id": "105",
                                    "fileName": "csr-vs-ssr.md",
                                    "name": "csr vs ssr",
                                    "type": "file",
                                    "content": "\nCSR stands for Client Side Rendering and SSR stands for Server Side Rendering. CSR pages are computed in your machine and then shown by your browser while in the case of SSR, the server sends ready to show Html content directly. Primarily React, Vue, and Angular apps are examples of CSR (technically it is possible for them to be executed in SSR mode too) and almost all older tech stacks are SSR like PHP, ruby on rails, java, dot net, etc. From the user's standpoint, CSR apps take higher time to render but compensate by avoiding page reloads later (SPA) while SSR apps often have faster initial load time but do a full page reload often.\n\nVisit the following resources to learn more:\n\n- [Server Side Rendering vs Client Side Rendering](https://www.youtube.com/watch?v=rNVcZklcmqU)\n- [SSR vs CSR vs SSG](https://medium.com/@prashantramnyc/server-side-rendering-ssr-vs-client-side-rendering-csr-vs-pre-rendering-using-static-site-89f2d05182ef)\n"
                                },
                                {
                                    "id": "106",
                                    "fileName": "responsive-vs-adaptive.md",
                                    "name": "responsive vs adaptive",
                                    "type": "file",
                                    "content": "\nThere are two approaches to ensuring a website is optimized for mobile, tablet, laptop and PC screens: responsive design and adaptive design. While both are intended to solve the same problem, they use different strategies.\n\n# What is responsive design?\n\nA website created with responsive design serves up the same site to every device, but that site is fluid and will change its layout and appearance based on the size and orientation of the device.\n\nDevelopers use CSS to ensure each page of the site can reformat based on the size of the user's viewport and only need to create one codebase for the site. They use something called breakpoints to tell the site when to adjust to accommodate different screen sizes.\n\nThe majority of new sites now use responsive, which has been made easier for less experienced designers and developers, thanks to the availability of themes accessible through CMS systems such as WordPress, Joomla, and Drupal.\n\nResponsive design does not offer as much control as adaptive, but takes much less work to both build and maintain. Responsive layouts are also fluid, and whilst adaptive can and do use percentages to give a more fluid feel when scaling, these can again cause a jump when a window is resized.\n\n# What is adaptive design?\n\nIn adaptive design, a different website layout is created for each device's screen. As it loads, the site recognizes the size of the screen and serves up the layout that was made for that viewport. In fact, you can create a different user experience for each of six common screen sizes from very small to very large: 320px, 480px, 760px, 960px, 1200px and 1600px.\n\nAdaptive is useful for retrofitting an existing site in order to make it more suitable for mobile phones. This allows you to take control of the design and web development for specific, multiple viewports. The number of viewports that you choose to design for is entirely up to you, your company, and your overall budget. It does, however, afford you a certain amount of control (for example over content and layout) that you will not necessarily have using responsive design.\n"
                                },
                                {
                                    "fileName": "index.md",
                                    "name": "index",
                                    "type": "file",
                                    "content": "\nFront End Testing is a testing technique in which Graphical User Interface (GUI), functionality and usability of web applications or a software are tested. The goal of Front end testing is testing overall functionalities to ensure the presentation layer of web applications or a software is defect free with successive updates.\n\nVisit the following resources to learn more:\n\n- [What is Front End Testing?](https://www.guru99.com/frontend-testing.html)\n"
                                }
                            ]
                        },
                        {
                            "id": "101",
                            "fileName": "browser-addons",
                            "name": "browser addons",
                            "type": "directory",
                            "children": [
                                {
                                    "id": "100",
                                    "fileName": "selenium-ide.md",
                                    "name": "selenium ide",
                                    "type": "file",
                                    "content": "\nSelenium IDE is an open source web automation testing tool from the Selenium Suite used primarily for QA purposes. It functions as a Firefox extension and does not require any programming knowledge and test cases can be created simply by interacting with the browser.\n\nSelenium itself is an open-source, automated testing tool used to test web applications across various browsers. It's primarily built in Java and supports several browsers and programming languages. Selenium IDE was developed to speed up the creation of automation scripts. It’s a rapid prototyping tool and can be used by engineers with no programming knowledge whatsoever. Because of its simplicity, Selenium IDE is best used as a prototyping tool and not a complete solution for developing and maintaining complex test suites.\n\nVisit the following resources to learn more:\n\n- [Selenium IDE Website](https://www.selenium.dev/selenium-ide/)\n- [Selenium IDE Tutorial](https://www.softwaretestinghelp.com/selenium-ide-script-selenium-tutorial-3/)\n"
                                },
                                {
                                    "id": "101",
                                    "fileName": "browser-addons.md",
                                    "name": "browser addons",
                                    "type": "file",
                                    "content": "\nWith website and app users expecting flawless software, spiffy updates and market-best features that keep getting better, software testers have their hands full, pretty much on a daily basis. Day-to-day QA operations go a lot smoother when testers have appropriate tools at hand.\n\nGiven that Chrome is the undisputed market leader in web browsers, it’s safe to assume that a large number of QAs are using Chrome for their work. Turns out, there are certain Chrome extensions that can actually help QAs work faster and more efficiently.\n\nVisit the following resources to learn more:\n\n- [8 Browser Plugins for Testing](https://blog.gurock.com/browser-plugins-for-testing/)\n- [15 Best Chrome Extensions for Software Testers](https://www.softwaretestingmaterial.com/chrome-extensions-for-software-testers/)\n"
                                },
                                {
                                    "id": "102",
                                    "fileName": "bug-management.md",
                                    "name": "bug management",
                                    "type": "file",
                                    "content": "\nExploratory Testing is all about exploring the software by navigating random paths and discovering what it can do and what it can’t. In exploratory testing we try to verify how well system reacts to special/invalid inputs and edge cases. Bug Magnet will help you configure Data validations and variety input scenarios likely to cause issues.\n\nVisit the following resources to learn more:\n\n- [Bug Magnet Website](https://bugmagnet.org/)\n- [Bug Magnet: Chrome Extension for Exploratory Testing](http://www.testingjournals.com/bug-magnet-extension-exploratory-testing/)\n"
                                },
                                {
                                    "id": "103",
                                    "fileName": "check-my-links.md",
                                    "name": "check my links",
                                    "type": "file",
                                    "content": "\nCheck My Links is a link checker that crawls through your webpage and looks for broken links. Is an extension developed primarily for web designers, developers and content editors.\n\nVisit the following resources to learn more:\n\n- [Check My Links Official Docs](https://github.com/PageModifiedOfficial/Check-My-Links)\n"
                                },
                                {
                                    "id": "104",
                                    "fileName": "ghost-inspector.md",
                                    "name": "ghost inspector",
                                    "type": "file",
                                    "content": "\nGhost Inspector is a codeless automated testing tool that allows you to easily create and run automated browser tests for websites and web applications. These tests carry out actions in a web browser the same way a real user would to ensure that everything is working properly.\n\nVisit the following resources to learn more:\n\n- [Ghost Inspector Website](https://ghostinspector.com/)\n- [What Is Ghost Inspector? Overview & Tour Of Features](https://theqalead.com/test-management/what-is-ghost-inspector-overview-tour-of-features/)\n"
                                }
                            ]
                        },
                        {
                            "id": "102",
                            "fileName": "automation-frameworks",
                            "name": "automation frameworks",
                            "type": "directory",
                            "children": [
                                {
                                    "id": "100",
                                    "fileName": "qa-wolf.md",
                                    "name": "qa wolf",
                                    "type": "file",
                                    "content": "\nQA Wolf is a hybrid platform & service that helps software teams ship better software faster by taking QA completely off their plate.\n\nVisit the following resources to learn more:\n\n- [QA Wolf](https://www.qawolf.com/)\n- [QA Wolf Official Docs](https://app.qawolf.com/docs/why-qa-wolf)\n- [Getting started with QA Wolf](https://app.qawolf.com/docs/create-a-test)\n- [QA Wolf Tutorial](https://www.youtube.com/watch?v=BRxVu0De-4k&list=PL33T95M59Kkg1zKCU5NHc2g2XYXOs3-DU)\n"
                                },
                                {
                                    "id": "101",
                                    "fileName": "cypress.md",
                                    "name": "cypress",
                                    "type": "file",
                                    "content": "\nCypress framework is a JavaScript-based end-to-end testing framework built on top of Mocha – a feature-rich JavaScript test framework running on and in the browser, making asynchronous testing simple and convenient. It also uses a BDD/TDD assertion library and a browser to pair with any JavaScript testing framework.\n\nVisit the following resources to learn more:\n\n- [Official Website](https://www.cypress.io/)\n- [Official Documentation](https://docs.cypress.io/guides/overview/why-cypress#Other)\n- [How it works](https://www.cypress.io/how-it-works)\n- [Cypress End-to-End Testing](https://www.youtube.com/watch?v=7N63cMKosIE)\n"
                                },
                                {
                                    "id": "102",
                                    "fileName": "webdriver-io.md",
                                    "name": "webdriver io",
                                    "type": "file",
                                    "content": "\nWebdriverIO is a progressive automation framework built to automate modern web and mobile applications. It simplifies the interaction with your app and provides a set of plugins that help you create a scalable, robust and stable test suite.\n\nWebdriverIO leverages the power of the WebDriver protocol that is developed and supported by all browser vendors and guarantees a true cross-browser testing experience. While other automation tools require you to download modified browser that aren't used by actual users or emulate user behavior by injecting JavaScript, WebdriverIO relies on a common agreed standard for automation that is properly tested and ensures compatibility for decades to come.\n\nDuring the development of this automation standard the web has changed a lot and many of the requirements that developers have today to test their web application can not be fulfilled using WebDriver anymore. While some of the core contributors of this project help support the next generation of the WebDriver protocol, WebdriverIO provides an alternative automation solution based on the Chrome DevTools protocol. This allows the user to seamlessly switch between conventional commands based on WebDriver and powerful browser interactions through Puppeteer.\n\nVisit the following resources to learn more:\n\n- [WebdriverIO Website](https://webdriver.io/)\n- [A brief overview of WebdriverIO](https://webdriver.io/docs/what-is-webdriverio)\n- [Getting started with WebdriverIO](https://webdriver.io/docs/gettingstarted)\n- [WebdriverIO Tutorial](https://www.youtube.com/watch?v=e8goAKb6CC0&list=PL6AdzyjjD5HBbt9amjf3wIVMaobb28ZYN)\n"
                                },
                                {
                                    "id": "103",
                                    "fileName": "jasmine.md",
                                    "name": "jasmine",
                                    "type": "file",
                                    "content": "\nJasmine is a very popular JavaScript BDD (behavior-driven development) framework for unit testing JavaScript applications. It provides utilities that can be used to run automated tests for both synchronous and asynchronous code. It does not depend on any other JavaScript frameworks. It does not require a DOM.\n\nVisit the following resources to learn more:\n\n- [Jasmines Official Website](https://jasmine.github.io/)\n- [Easy and Practical example of Angular testing with Jasmine](https://semaphoreci.com/community/tutorials/testing-components-in-angular-2-with-jasmine)\n- [Starting with Jasmine from Scratch](https://www.testim.io/blog/jasmine-js-a-from-scratch-tutorial-to-start-testing)\n"
                                },
                                {
                                    "id": "104",
                                    "fileName": "nightwatch.md",
                                    "name": "nightwatch",
                                    "type": "file",
                                    "content": "\nNightwatch.js is an open-source automated testing framework that is powered by Node.js and provides complete E2E (end to end) solutions to automation testing with Selenium Javascript be it for web apps, browser apps, and websites.\n\nVisit the following resources to learn more:\n\n- [Nightwatch.js Website](https://nightwatchjs.org/)\n- [NightwatchJS Tutorial: Get Started with Automation Testing](https://www.browserstack.com/guide/nightwatch-framework-tutorial)\n"
                                },
                                {
                                    "id": "105",
                                    "fileName": "robot-framework.md",
                                    "name": "robot framework",
                                    "type": "file",
                                    "content": "\nRobot Framework is a Python-based, extensible keyword-driven automation framework for acceptance testing, acceptance test driven development (ATDD), behavior driven development (BDD) and robotic process automation (RPA).\n\nRobot Framework is open and extensible. Robot Framework can be integrated with virtually any other tool to create powerful and flexible automation solutions.\n\nVisit the following resources to learn more:\n\n- [Robot Framework Official Website](https://robotframework.org/)\n- [Robot Framework Official User Guide](https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html)\n- [Basic Step-by-step Robot Framework tutorial](https://medium.com/swlh/robot-framework-the-basics-dfeadc025bea)\n- [Excellent tutorial to start working with Robot Framework](https://www.geeksforgeeks.org/robot-framework-in-python/)\n"
                                },
                                {
                                    "id": "106",
                                    "fileName": "selenium.md",
                                    "name": "selenium",
                                    "type": "file",
                                    "content": "\nSelenium is an open-source tool that automates web browsers. It provides a single interface that lets you write test scripts in programming languages like Ruby, Java, NodeJS, PHP, Perl, Python, and C#, among others.\n\nVisit the following resources to learn more:\n\n- [Seleniums Official Website](https://www.selenium.dev/)\n- [Selenium Tutorial](https://www.browserstack.com/selenium)\n"
                                },
                                {
                                    "id": "107",
                                    "fileName": "jest.md",
                                    "name": "jest",
                                    "type": "file",
                                    "content": "\nJest is a delightful JavaScript Testing Framework with a focus on simplicity.\nIt works with projects using: Babel, TypeScript, Node, React, Angular, Vue and more!\n\nVisit the following resources to learn more:\n\n- [Official Website](https://jestjs.io/)\n- [Official Documentation](https://jestjs.io/docs/getting-started)\n- [Jest Crash Course - Unit Testing in JavaScript](https://www.youtube.com/watch?v=7r4xVDI2vho)\n"
                                },
                                {
                                    "id": "108",
                                    "fileName": "puppeteer.md",
                                    "name": "puppeteer",
                                    "type": "file",
                                    "content": "\nPuppeteer is a Node library which provides a high-level API to control headless Chrome or Chromium over the DevTools Protocol. It can also be configured to use full (non-headless) Chrome or Chromium.\n\nVisit the following resources to learn more:\n\n- [Puppetter](https://developer.chrome.com/docs/puppeteer/)\n- [Puppetter Tutorial](https://www.freecodecamp.org/news/how-to-use-puppeteer-with-nodejs/)\n"
                                },
                                {
                                    "id": "109",
                                    "fileName": "playwright.md",
                                    "name": "playwright",
                                    "type": "file",
                                    "content": "\nPlaywright Test was created specifically to accommodate the needs of end-to-end testing. Playwright supports all modern rendering engines including Chromium, WebKit, and Firefox. Test on Windows, Linux, and macOS, locally or on CI, headless or headed with native mobile emulation of Google Chrome for Android and Mobile Safari.Playwright leverages the DevTools protocol to write powerful, stable automated tests.Playwright can actually see into and control the browser rather than relying on a middle translation layer, it allows for the simulation of more insightful and relevant user scenarios.\n\nVisit the following resources to learn more:\n\n- [Official Website: Playwright](https://playwright.dev/)\n- [Playwright Tutorial](https://www.browserstack.com/guide/playwright-tutorial)\n"
                                },
                                {
                                    "fileName": "index.md",
                                    "name": "index",
                                    "type": "file",
                                    "content": "\nA Test Automation Framework is a set of guidelines like coding standards, test-data handling, object repository treatment, etc… which when followed during automation scripting produces beneficial outcomes like increased code re-usage, higher portability or reduced script maintenance cost.\n\nVisit the following resources to learn more:\n\n- [Test Automation Framework: What is, Architecture & Types](https://www.guru99.com/test-automation-framework.html)\n- [Popular Test Automation Frameworks](https://www.browserstack.com/guide/best-test-automation-frameworks)\n"
                                }
                            ]
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nFront-end automation is a way to characterize automation that streamlines tasks focused on interactivity, websites, and attended processes. Robotic process automation, or RPA, is considered automation on the front end, or from the user-interface (UI) level. Benefits of front-end automation include quick task building with no programming knowledge, no required changes to existing programs or applications, and those individuals who know the keystrokes can easily build the automation task.\n\nVisit the following resources to learn more:\n\n- [How we do automated testing on our frontend](https://dev.to/davidz/how-we-do-automated-testing-on-our-frontend-b10)\n"
                        }
                    ]
                },
                {
                    "id": "101",
                    "fileName": "mobile-automation",
                    "name": "mobile automation",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "appium.md",
                            "name": "appium",
                            "type": "file",
                            "content": "\nAppium is an open-source framework that allows QAs to conduct automated app testing on different platforms like Android, iOS, and Windows. It is developed and supported by Sauce Labs to automate native and hybrid mobile apps. It is a cross-platform mobile automation tool, which means that it allows the same test to be run on multiple platforms.\n\nVisit the following resources to learn more:\n\n- [Appium Website](https://appium.io/)\n- [Appium Tutorial for Mobile Application Testing](https://www.browserstack.com/guide/appium-tutorial-for-testing)\n- [Appium Website](https://appium.io/docs/en/2.0/intro/)\n- [Appium example tests on Github](https://github.com/appium/appium/tree/1.x/sample-code)\n"
                        },
                        {
                            "id": "101",
                            "fileName": "xcuitest.md",
                            "name": "xcuitest",
                            "type": "file",
                            "content": "\nMobile app testing, and more specifically, app UI testing involves checking how the interface behaves when user actions are performed and then compares results with expected outcomes. Here, testers try to replicate exactly how a user would interact with the application and validate the state of the UI. XCUITest allows them to write test cases for these purposes using two fundamental concepts.\n\nVisit the following resources to learn more:\n\n- [Official Documentation](https://developer.apple.com/documentation/xctest/)\n- [Getting Started with XCUITest](https://www.browserstack.com/guide/getting-started-xcuitest-framework)\n- [Xcuitest - End to End Testing](https://testautomationu.applitools.com/learningpaths.html?id=mobile-swift-path)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "espresso.md",
                            "name": "espresso",
                            "type": "file",
                            "content": "\nEspresso is a native testing framework for Android to write reliable UI tests. Google released the Espresso framework in October 2013 and, as of release version 2.0, Espresso is part of the Android Support Repository. One of the important features in Espresso is that it automatically synchronizes your test actions with the user interface of your application. The framework also ensures that your activity is started before the test runs. It can also force a test to wait until all observer background activities have finished, which is sometimes a problem with other testing frameworks.\n\nVisit the following resources to learn more:\n\n- [Official Documentation](https://developer.android.com/training/testing/espresso#kotlin)\n- [Espresso Testing Tutorial](https://www.tutorialspoint.com/espresso_testing/index.htm)\n- [Espresso Code Samples on Github](https://github.com/android/testing-samples)\n"
                        },
                        {
                            "id": "103",
                            "fileName": "detox.md",
                            "name": "detox",
                            "type": "file",
                            "content": "\nDetox is a JavaScript mobile testing framework that is built into the application and the test execution starts with app launch. This makes test execution really fast and robust as no external additional tools are needed to orchestrate and synchronize during the test execution.\n\nVisit the following resources to learn more:\n\n- [Detox Website](https://wix.github.io/Detox/)\n- [Getting Started with Detox](https://wix.github.io/Detox/docs/introduction/getting-started)\n- [Test Automation Tools: Detox](https://www.spritecloud.com/test-automation-tools-detox/)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nMobile automation, as the name suggests, refers to 'automation' that is done on mobile devices. Mobile Automation can test a WAP site or an app. As we know, mobile devices consist of hardware and software components, while a mobile application is simply the software. Testing the mobile device is also connected to evaluating the hardware component and the software part.\n\nVisit the following resources to learn more:\n\n- [Mobile Automation Testing Steps and Process](https://u-tor.com/topic/mobile-automation-steps)\n"
                        }
                    ]
                },
                {
                    "id": "102",
                    "fileName": "backend-automation",
                    "name": "backend automation",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "karate-framework.md",
                            "name": "karate framework",
                            "type": "file",
                            "content": "\nKarate is the only open-source tool to combine API test-automation, mocks, performance-testing and even UI automation into a single, unified framework. The BDD syntax popularized by Cucumber is language-neutral, and easy for even non-programmers. Assertions and HTML reports are built-in, and you can run tests in parallel for speed.\n\nThere's also a cross-platform stand-alone executable for teams not comfortable with Java. You don't have to compile code. Just write tests in a simple, readable syntax - carefully designed for HTTP, JSON, GraphQL and XML. And you can mix API and UI test-automation within the same test script.\n\nA Java API also exists for those who prefer to programmatically integrate Karate's rich automation and data-assertion capabilities.\n\nVisit the following resources to learn more:\n\n- [karate website](https://www.karatelabs.io/)\n- [karate architecture](https://github.com/karatelabs/karate/blob/master/karate-core/src/test/resources/karate-map.jpg?raw=true)\n- [karate for beginner](https://www.youtube.com/watch?v=1f6xtJpRx4k&list=PLhW3qG5bs-L-y5Q1zDXJAur1JNZVFB534)\n"
                        },
                        {
                            "id": "101",
                            "fileName": "cypress.md",
                            "name": "cypress",
                            "type": "file",
                            "content": "\nCypress framework is a JavaScript-based end-to-end testing framework built on top of Mocha – a feature-rich JavaScript test framework running on and in the browser, making asynchronous testing simple and convenient. It also uses a BDD/TDD assertion library and a browser to pair with any JavaScript testing framework.\n\nVisit the following resources to learn more:\n\n- [Official Website](https://www.cypress.io/)\n- [Official Documentation](https://docs.cypress.io/guides/overview/why-cypress#Other)\n- [Cypress End-to-End Testing](https://www.youtube.com/watch?v=7N63cMKosIE)\n- [Cypress Tips & Trics](https://www.youtube.com/watch?v=PZ2OsLBts1E&list=PLP9o9QNnQuAYYRpJzDNWpeuOVTwxmIxcI)\n- [Cypress - End to End Testing Framework](https://dev.to/bushraalam/cypress-end-to-end-testing-framework-3naa)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "soap-ui.md",
                            "name": "soap ui",
                            "type": "file",
                            "content": "\nSoapUI is the world's leading Functional Testing tool for SOAP and REST testing. With its easy-to-use graphical interface, and enterprise-class features, SoapUI allows you to easily and rapidly create and execute automated functional, regression, and load tests.\n\nVisit the following resources to learn more:\n\n- [SoapUI Official Website](https://www.soapui.org/)\n- [SoapUI Docs](https://www.soapui.org/getting-started/)\n"
                        },
                        {
                            "id": "103",
                            "fileName": "postman-newman.md",
                            "name": "postman newman",
                            "type": "file",
                            "content": "\nPostman is an API platform for building and using APIs. Postman simplifies each step of the API lifecycle and streamlines collaboration so you can create better APIs—faster. It is an API client that makes it easy for developers to create, share, test, and document APIs. With this open-source solution, users can create and save simple and complex HTTP/s requests and read their responses.\n\nNewman is a command-line Collection Runner for Postman. It enables you to run and test a Postman Collection directly from the command line. It's built with extensibility to integrate it with your continuous integration servers and build systems.\n\nVisit the following resources to learn more:\n\n- [Postman website](https://www.postman.com)\n- [Learn postman](https://learning.postman.com/docs/getting-started/introduction/)\n- [API testing with postman](https://www.youtube.com/watch?v=VywxIQ2ZXw4)\n- [ Newman cli usage](https://learning.postman.com/docs/running-collections/using-newman-cli/command-line-integration-with-newman/)\n"
                        },
                        {
                            "id": "104",
                            "fileName": "rest-assured.md",
                            "name": "rest assured",
                            "type": "file",
                            "content": "\nRest-assured helps developers and test engineers to test REST APIs in Java ease by using techniques used in dynamic languages such as Groovy and Ruby.\n\nVisit the following resources to learn more:\n\n- [REST-assured Website](https://rest-assured.io)\n- [REST Assured Tutorial: How to test API with Example](https://www.guru99.com/rest-assured.html)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nBackend Testing is a testing method that checks the server side or database of web applications or software. Backend testing aims to test the application layer or database layer to ensure that the web application or software is free from database defects like deadlock, data corruption, or data loss.\n\nVisit the following resources to learn more:\n\n- [What is backend testing?](https://testinggenez.com/what-is-backend-testing-and-types/)\n- [Backend Testing Tutorial](https://www.guru99.com/what-is-backend-testing.html)\n"
                        }
                    ]
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nAutomation Testing is a software testing technique that performs using special automated testing software tools to execute a test case suite. On the contrary, Manual Testing is performed by a human sitting in front of a computer carefully executing the test steps.\n\nAutomated testing is the application of software tools to automate a human-driven manual process of reviewing and validating a software product. Most modern agile and DevOps software projects now include automated testing from inception. To fully appreciate the value of automated testing, however, it helps to understand what life was like before it was widely adopted.\n\nVisit the following resources to learn more:\n\n- [What is Automated Testing?](https://www.atlassian.com/continuous-delivery/software-testing/automated-testing)\n- [Testing Pyramid](https://www.browserstack.com/guide/testing-pyramid-for-test-automation)\n- [Learning Path with different programming language](https://testautomationu.applitools.com/learningpaths.html)\n"
                }
            ]
        },
        {
            "id": "104",
            "fileName": "qa-non-functional-testing",
            "name": "qa non functional testing",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "load-and-performance-testing",
                    "name": "load and performance testing",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "vegeta.md",
                            "name": "vegeta",
                            "type": "file",
                            "content": "\nVegeta is a versatile HTTP load testing tool built out of a need to drill HTTP services with a constant request rate. It can be used both as a command line utility and a library.\n\nVisit the following resources to learn more:\n\n- [Vegeta Website](https://github.com/tsenart/vegeta)\n"
                        },
                        {
                            "id": "101",
                            "fileName": "jmeter.md",
                            "name": "jmeter",
                            "type": "file",
                            "content": "\nApache JMeter is an Apache project that can be used as a load testing tool for analyzing and measuring the performance of a variety of services, with a focus on web applications.\n\nVisit the following resources to learn more:\n\n- [Apache JMeter Website](https://jmeter.apache.org/)\n- [Learn JMeter](https://www.youtube.com/playlist?list=PLJ9A48W0kpRIjLkZ32Do9yDZXnnm7_uj_)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "locust.md",
                            "name": "locust",
                            "type": "file",
                            "content": "\nLocust is an easy-to-use, scriptable and scalable performance testing tool. You define the behavior of your users in regular Python code instead of being stuck in a UI or restrictive domain-specific language. This makes Locust infinitely expandable and very developer friendly. Given below are some of the features of Locust.\n\n- Write test scenarios in plain old Python\n- Distributed and scalable - supports hundreds of thousands of concurrent users\n- Web-based UI\n- Can test any system\n- Hackable\n\nVisit the following resources to learn more:\n\n- [Locust Website](https://locust.io/)\n- [Learn Locust](https://www.youtube.com/playlist?list=PLJ9A48W0kpRKMCzJARCObgJs3SinOewp5)\n"
                        },
                        {
                            "id": "103",
                            "fileName": "gatling.md",
                            "name": "gatling",
                            "type": "file",
                            "content": "\nGatling is a highly capable load testing tool. It is designed for ease of use, maintainability and high performance.\n\nOut of the box, Gatling comes with excellent support of the HTTP protocol that makes it a tool of choice for load testing any HTTP server. As the core engine is actually protocol agnostic, it is perfectly possible to implement support for other protocols. For example, Gatling currently also ships JMS support.\n\nGatling’s architecture is asynchronous as long as the underlying protocol, such as HTTP, can be implemented in a non blocking way. This kind of architecture lets us implement virtual users as messages instead of dedicated threads, making them very resource cheap. Thus, running thousands of concurrent virtual users is not an issue.\n\nVisit the following resources to learn more:\n\n- [Gatling Website](https://gatling.io/)\n- [Learn Gatling](https://www.youtube.com/playlist?list=PLJ9A48W0kpRJE6s8I1MjWm-z8BGbUYNCw)\n"
                        },
                        {
                            "id": "104",
                            "fileName": "k6.md",
                            "name": "k6",
                            "type": "file",
                            "content": "\nGrafana k6 is an open-source load testing tool that makes performance testing easy and productive for engineering teams. k6 is free, developer-centric, and extensible.\n\nUsing k6, you can test the reliability and performance of your systems and catch performance regressions and problems earlier. k6 will help you to build resilient and performant applications that scale.\n\nVisit the following resources to learn more:\n\n- [k6 Website](https://k6.io/)\n- [Learn k6](https://www.youtube.com/playlist?list=PLJ9A48W0kpRJKmVeurt7ltKfrOdr8ZBdt)\n"
                        },
                        {
                            "id": "105",
                            "fileName": "artillery.md",
                            "name": "artillery",
                            "type": "file",
                            "content": "\nArtillery is a modern, powerful & easy-to-use performance testing toolkit. Use it to ship scalable applications that stay performant & resilient under high load.\n\nArtillery prioritizes developer productivity and happiness, and follows the \"batteries-included\" philosophy.\n\n## Features\n\n- Emulate complex user behavior with scenarios\n- Load testing and smoke testing\n- Batteries included\n- Extensible & hackable\n- Integrations and add-ons\n- Designed for cross-team collaboration\n- Planet-scale testing\n\nVisit the following resources to learn more:\n\n- [Artillery Website](https://www.artillery.io/)\n- [Learn Artillery](https://www.youtube.com/playlist?list=PLJ9A48W0kpRJh1_uW2mVNhSIVCMYmNlm7)\n"
                        },
                        {
                            "id": "106",
                            "fileName": "lighthouse.md",
                            "name": "lighthouse",
                            "type": "file",
                            "content": "\nLighthouse is an open-source, automated tool for improving the quality of web pages. You can run it against any web page, public or requiring authentication. It has audits for performance, accessibility, progressive web apps, SEO, and more. You can run Lighthouse in Chrome DevTools, from the command line, or as a Node module. You give Lighthouse a URL to audit, run a series of audits against the page, and then generate a report on how well the page did. From there, use the failing audits as indicators on how to improve the page. Each audit has a reference doc explaining why the audit is important and how to fix it.\n\nVisit the following resources to learn more:\n\n- [Lighthouse Website](https://github.com/GoogleChrome/lighthouse/)\n"
                        },
                        {
                            "id": "107",
                            "fileName": "webpage-test.md",
                            "name": "webpage test",
                            "type": "file",
                            "content": "\nWebPageTest is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n\nEach test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n\nVisit the following resources to learn more:\n\n- [WebPageTest Website](https://www.webpagetest.org/)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nPerformance Testing is a subset of Performance Engineering. It is a process of evaluating a system’s behavior under various extreme conditions. The main intent of performance testing is to monitor and improve key performance indicators such as response time, throughput, memory, CPU utilization, and more.\n\nThere are three objectives (three S) of Performance testing to observe and evaluate: `Speed`, `Scalability` and `Stability`. Following are the commonly used performance testing types, but not limited to:\n\n- Load Testing\n- Stress Testing\n- Spike Testing\n- Endurance Testing\n- Volume Testing\n- Scalability Testing\n- Capacity Testing\n\nLoad Testing is one type of performance testing. It helps to evaluate the application under tests' behaviors such as response time, throughput, pass/fail transactions, and more under the normal workload. e.g., cart checkout response time is 500 milliseconds under typical business hours.\n"
                        }
                    ]
                },
                {
                    "id": "101",
                    "fileName": "accessibility-testing",
                    "name": "accessibility testing",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "chrome-devtools.md",
                            "name": "chrome devtools",
                            "type": "file",
                            "content": "\nThese are a set of tools built into the browser to aid frontend developers diagnose and solve various issues in their applications — such as JavaScript and logical bugs, CSS styling issues or even just making quick temporary alterations to the DOM.\n\nTo enter the dev tools, right click and click **Inspect** (or press `ctrl+shift+c`/`cmd+opt+c`) to enter the Elements panel. Here you can debug CSS and HTML issues. If you want to see logged messages or interact with javascript, enter the **Console** tab from the tabs above (or press `ctrl+shift+j`/`cmd+opt+j` to enter it directly). Another very useful feature in the Chrome dev tools is the Lighthouse (for checking performance) — more on this later.\n\nNOTE: This isn't a chrome-specific feature, and most browsers (Chromium based or otherwise) will have their own, largely-similar set of devtools.\n\nVisit the following resources to learn more:\n\n- [Official Docs](https://developer.chrome.com/docs/devtools/overview/)\n- [Mastering Chrome Dev Tools](https://www.freecodecamp.org/news/mastering-chrome-developer-tools-next-level-front-end-development-techniques-3ac0b6fe8a3/)\n"
                        },
                        {
                            "id": "101",
                            "fileName": "wave.md",
                            "name": "wave",
                            "type": "file",
                            "content": "\nWave is a suite of evaluation tools that helps authors make their web content more accessible to individuals with disabilities. WAVE can identify many accessibility and Web Content Accessibility Guideline (WCAG) errors, but also facilitates human evaluation of web content.\n\nVisit the following resources to learn more:\n\n- [Wave Website](https://wave.webaim.org/)\n- [WAVE Accessibility Testing Tool Tutorial](https://www.softwaretestinghelp.com/web-accessibility-testing-tools/)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "axe.md",
                            "name": "axe",
                            "type": "file",
                            "content": "\nAxe is a fast and lightweight accessibility testing tool that checks the entire document against the rules and generates a report with all violations, passes, etc.\n\nVisit the following resources to learn more:\n\n- [Axe Website](https://www.deque.com/axe/)\n- [Accessibility testing using the axe-core library](https://www.browserstack.com/docs/automate/selenium/accessibility-testing)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nIn software QA, accessibility testing is the practice of confirming that an application is usable for as many people as possible, including people with disabilities such as vision impairment, hearing problems and cognitive conditions.\n\nVisit the following resources to learn more:\n\n- [Accessibility testing -Javapoint](https://www.javatpoint.com/accessibility-testing)\n- [Accessibility testing -geeksforgeeks](https://www.geeksforgeeks.org/software-testing-accessibility-testing/)\n"
                        }
                    ]
                },
                {
                    "id": "102",
                    "fileName": "security-testing",
                    "name": "security testing",
                    "type": "directory",
                    "children": [
                        {
                            "id": "100",
                            "fileName": "authentication-authorization.md",
                            "name": "authentication authorization",
                            "type": "file",
                            "content": "\n`Authentication` is the process of verifying that an individual, entity or website is whom it claims to be. Authentication in the context of web applications is commonly performed by submitting a username or ID and one or more items of private information that only a given user should know.\n\n`Authorization` may be defined as \"the process of verifying that a requested action or service is approved for a specific entity\" (NIST). `Authorization` is distinct from authentication which is the process of verifying an entity's identity. When designing and developing a software solution, it is important to keep these distinctions in mind. A user who has been authenticated (perhaps by providing a username and password) is often not authorized to access every resource and perform every action that is technically possible through a system.\n\nFor example, a web app may have both regular users and admins, with the admins being able to perform actions the average user is not privileged to do so, even though they have been authenticated. Additionally, authentication is not always required for accessing resources; an unauthenticated user may be authorized to access certain public resources, such as an image or login page, or even an entire web app.\n\nVisit the following resources to learn more:\n\n- [OWASP Website](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)\n"
                        },
                        {
                            "id": "101",
                            "fileName": "vulnerability-scanning.md",
                            "name": "vulnerability scanning",
                            "type": "file",
                            "content": "\nVulnerability scanning identifies hosts and host attributes\n(e.g., operating systems, applications, open ports), but it also attempts to identify vulnerabilities rather\nthan relying on human interpretation of the scanning results. Many vulnerability scanners are equipped to\naccept results from network discovery and network port and service identification, which reduces the\namount of work needed for vulnerability scanning.\n\nAlso, some scanners can perform their own network\ndiscovery and network port and service identification. Vulnerability scanning can help identify outdated\nsoftware versions, missing patches, and misconfigurations, and validate compliance with or deviations\nfrom an organization’s security policy.\n\nThis is done by identifying the operating systems and major\nsoftware applications running on the hosts and matching them with information on known vulnerabilities\nstored in the scanners’ vulnerability databases.\n\nVisit the following resources to learn more:\n\n- [NIST Website](https://csrc.nist.gov/glossary/term/vulnerability_scanning)\n"
                        },
                        {
                            "id": "102",
                            "fileName": "owasp-10.md",
                            "name": "owasp 10",
                            "type": "file",
                            "content": "\nThe Open Web Application Security Project, or OWASP, is an international non-profit organization dedicated to web application security.\n\nThe OWASP Top 10 is a regularly-updated report outlining security concerns for web application security, focusing on the 10 most critical risks. The report is put together by a team of security experts from all over the world. OWASP refers to the Top 10 as an ‘awareness document’ and they recommend that all companies incorporate the report into their processes in order to minimize and/or mitigate security risks.\n\nVisit the following resources to learn more:\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [What is the OWASP Top 10?](https://www.cloudflare.com/learning/security/threats/owasp-top-10/)\n"
                        },
                        {
                            "id": "103",
                            "fileName": "attack-vectors.md",
                            "name": "attack vectors",
                            "type": "file",
                            "content": "\nThis metric reflects the context by which vulnerability exploitation is possible. This metric value (and consequently the Base Score) will be larger the more remote (logically, and physically) an attacker can be in order to exploit the vulnerable component. The assumption is that the number of potential attackers for a vulnerability that could be exploited from across a network is larger than the number of potential attackers that could exploit a vulnerability requiring physical access to a device, and therefore warrants a greater Base Score.\n\nVisit the following resources to learn more:\n\n- [FIRST.org Website](https://www.first.org/cvss/v3.1/specification-document)\n"
                        },
                        {
                            "id": "104",
                            "fileName": "secrets-management.md",
                            "name": "secrets management",
                            "type": "file",
                            "content": "\nSecrets Management is a systematic way of in managing, storing, securing, and retrieving credentials for any systems, database, and other services.\n\nCredentials such as passwords, SSH keys, certificates, API keys, backup codes, and more.\n\nVisit the following resources to learn more:\n\n- [AWS Secrets Management Website](https://aws.amazon.com/secrets-manager/)\n- [Vault Website](https://www.vaultproject.io/)\n"
                        },
                        {
                            "fileName": "index.md",
                            "name": "index",
                            "type": "file",
                            "content": "\nSecurity testing is a process intended to reveal flaws in the security mechanisms of an information system that protect data and maintain functionality as intended. Due to the logical limitations of security testing, passing the security testing process is not an indication that no flaws exist or that the system adequately satisfies the security requirements.\n\nTypical security requirements may include specific elements of confidentiality, integrity, authentication, availability, authorization and non-repudiation. Actual security requirements tested depend on the security requirements implemented by the system. Security testing as a term has a number of different meanings and can be completed in a number of different ways. As such, a Security Taxonomy helps us to understand these different approaches and meanings by providing a base level to work from.\n\nVisit the following resources to learn more:\n\n- [Security Testing Wiki](https://en.wikipedia.org/wiki/Security_testing)\n"
                        }
                    ]
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nIn the process of Software testing, testing and analyzing only software’s functions doesn't complete the testing process. There are some other attributes which will demonstrate the entire software quality, they are known as quality characteristics. These characteristics include performance, security, usability, and reliability. Also not testing and analyzing the report of these characteristics will not affect the function of software, it will work to a degree of extent, but testing of these quality characteristics are referred to as QA non-functional testing.\n"
                }
            ]
        },
        {
            "id": "105",
            "fileName": "qa-email-testing",
            "name": "qa email testing",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "mailinator.md",
                    "name": "mailinator",
                    "type": "file",
                    "content": "\nMailinator allows Developers and QA Testing teams to automatically test their SMS and Email workflows like 2FA verifications, sign-ups, and password resets with trillions of inboxes at your fingertips. Whether you do Manual Testing, use an API, or a framework like Selenium, Cypress, Playwright, or Puppeteer - Mailinator will close the loop on email/SMS testing.\n\nVisit the following resources to learn more:\n\n- [Mailinator](https://www.mailinator.com/)\n- [Mailinator Official Docs](https://www.mailinator.com/docs/index.html#mailinator)\n"
                },
                {
                    "id": "101",
                    "fileName": "gmail-tester.md",
                    "name": "gmail tester",
                    "type": "file",
                    "content": "\nGmail-tester is a simple Node.js Gmail client which checks/returns email message(s) straight from any Gmail-powered account (both private and company).\n\nVisit the following resources to learn more:\n\n- [Gmail-tester Website](https://www.npmjs.com/package/gmail-tester)\n- [Using the gmail-tester + Puppeteer to poll Gmail inbox](https://medium.com/@sergtimosh/using-gmail-tester-puppeteer-to-poll-gmail-inbox-65bbee17618c)\n"
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nEmail testing allows you to view your email before sending it out to your subscriber list to verify links, design, spelling errors, and more.\n\nVisit the following resources to learn more:\n\n- [About Email Testing](https://www.campaignmonitor.com/blog/email-marketing/how-email-testing-and-rendering-works-and-why-its-important/)\n- [Checklist: How to Test and QA an Email](https://sponge.io/checklist-how-to-test-and-qa-an-email/)\n"
                }
            ]
        },
        {
            "id": "106",
            "fileName": "qa-reporting",
            "name": "qa reporting",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "junit.md",
                    "name": "junit",
                    "type": "file",
                    "content": "\nJUnit is known as a unit testing framework used for the Java programming language. JUnit has been playing a crucial in the development of test-driven development and is one of a family of unit testing frameworks. JUnit is useful to write repeatable tests for your application code units. JUnit stimulates the idea of “testing first, then coding,”. The test approach explicates –test a little + code a little = JUnit. JUnit helps the programmer by increasing the productivity and the stability of the program’s code snippets.That will helps in reducing the time of the tester, which is spent on debugging of the code.\n\nVisit the following resources to learn more:\n\n- [What is JUnit?](https://www.tutorialspoint.com/junit/junit_test_framework.htm)\n"
                },
                {
                    "id": "101",
                    "fileName": "allure.md",
                    "name": "allure",
                    "type": "file",
                    "content": "\nAllure Report is a flexible, lightweight multi-language test reporting tool. It provides clear graphical reports and allows everyone involved in the development process to extract the maximum of information from the everyday testing process.\n\nVisit the following resources to learn more:\n\n- [Allure](https://qameta.io/)\n- [Allure Official Docs](https://docs.qameta.io/allure-report/)\n"
                },
                {
                    "id": "102",
                    "fileName": "test-rail.md",
                    "name": "test rail",
                    "type": "file",
                    "content": "\nTestRail is a web-based test management tool used by testers, developers and other stake holders to manage, track and organize software testing efforts. It follows a centralized test management concept that helps in easy communication and enables rapid development of task across QA team and other stakeholders .\n\nVisit the following resources to learn more:\n\n- [Testrail](https://www.gurock.com/testrail/)\n- [Testrail Official Docs](https://support.gurock.com/hc/en-us/)\n- [Testrail Tutorial Docs](https://www.tutorialspoint.com/testrail/testrail_introduction.htm)\n"
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nThe International Software Testing Qualifications Board (ISTQB) glossary defines a QA report as: _Documentation summarizing test activities and results_.\nBy documenting the testing that was conducted and the results that were achieved, QA reports provide valuable insight into the health of the code base and critical metrics. As such, they should be generated on a regular basis to ensure the quality standards are being met.\nSo basically, test reports should document all of the test cases that were performed during software testing, as well as the results of those tests. They should also deliver relevant information about the product and highlight any areas where improvements can be made.\n\nVisit the following resources to learn more:\n\n- [How do you write a QA report?](https://www.netguru.com/blog/how-to-write-qa-report)\n- [How To Write QA Test Summary Report? [13 Easy Steps]](https://www.qatouch.com/blog/how-to-write-qa-test-summary-report/)\n"
                }
            ]
        },
        {
            "id": "107",
            "fileName": "qa-monitoring-logs",
            "name": "qa monitoring logs",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "grafana.md",
                    "name": "grafana",
                    "type": "file",
                    "content": "\nGrafana is the open-source platform for monitoring and observability. It allows you to query, visualize, alert on and understand your metrics no matter where they are stored.\n\nVisit the following resources to learn more:\n\n- [Grafana Website](https://grafana.com/)\n- [Grafana Official Documentation](https://grafana.com/docs/)\n- [Grafana Community](https://community.grafana.com/)\n- [Grafana Webinars and Videos](https://grafana.com/videos/)\n"
                },
                {
                    "id": "101",
                    "fileName": "new-relic.md",
                    "name": "new relic",
                    "type": "file",
                    "content": "\nNew Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it.\n\nVisit the following resources to learn more:\n\n- [New Relic Website](https://newrelic.com/)\n- [Learn New Relic](https://learn.newrelic.com/)\n"
                },
                {
                    "id": "102",
                    "fileName": "run-scope.md",
                    "name": "run scope",
                    "type": "file",
                    "content": "\nA Simple Tool for Monitoring Complex APIs. Verify that the structure and content of your API calls meets your expectations. Powerful and flexible assertions give you total control over defining a successful API call.\n\nCreate simple monitors with dynamic data for even the most complex use cases. More than simple string matching, build API validations without any code and use them across local dev, staging and production environments.\n\nVisit the following resources to learn more:\n\n- [Runscope Website](https://www.runscope.com)\n"
                },
                {
                    "id": "103",
                    "fileName": "sentry.md",
                    "name": "sentry",
                    "type": "file",
                    "content": "\nSentry tracks your software performance, measuring metrics like throughput and latency, and displaying the impact of errors across multiple systems. Sentry captures distributed traces consisting of transactions and spans, which measure individual services and individual operations within those services.\n\nVisit the following resources to learn more:\n\n- [Sentry Website](https://sentry.io)\n"
                },
                {
                    "id": "104",
                    "fileName": "kibana.md",
                    "name": "kibana",
                    "type": "file",
                    "content": "\nKibana is a free and open user interface that lets you visualize your Elasticsearch data and navigate the Elastic Stack. Do anything from tracking query load to understanding the way requests flow through your apps.\n\nVisit the following resources to learn more:\n\n- [Elastic Kibana Website](https://www.elastic.co/kibana/)\n- [Learn Kibana](https://www.elastic.co/training/free)\n"
                },
                {
                    "id": "105",
                    "fileName": "data-dog.md",
                    "name": "data dog",
                    "type": "file",
                    "content": "\nDatadog is a monitoring and analytics platform for large-scale applications. It encompasses infrastructure monitoring, application performance monitoring, log management, and user-experience monitoring. Datadog aggregates data across your entire stack with 400+ integrations for troubleshooting, alerting, and graphing.\n\nVisit the following resources to learn more:\n\n- [Datadog Website](https://www.datadoghq.com/)\n- [Official Documentation](https://docs.datadoghq.com/)\n"
                },
                {
                    "id": "106",
                    "fileName": "pager-duty.md",
                    "name": "pager duty",
                    "type": "file",
                    "content": "\nThrough its SaaS-based platform, PagerDuty empowers developers, DevOps, IT operations and business leaders to prevent and resolve business-impacting incidents for exceptional customer experience. When revenue and brand reputation depends on customer satisfaction, PagerDuty arms organizations with the insight to proactively manage events that may impact customers across their IT environment. With hundreds of native integrations, on-call scheduling and escalations, machine learning, business-wide response orchestration, analytics, and much more, PagerDuty gets the right data in the hands of the right people in real time, every time.\n\nVisit the following resources to learn more:\n\n- [PagerDuty Website](https://www.pagerduty.com/)\n- [Learn PagerDuty](https://university.pagerduty.com/)\n"
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nDevOps monitoring entails overseeing the entire development process from planning, development, integration and testing, deployment, and operations. It involves a complete and real-time view of the status of applications, services, and infrastructure in the production environment. Features such as real-time streaming, historical replay, and visualizations are critical components of application and service monitoring.\n"
                }
            ]
        },
        {
            "id": "108",
            "fileName": "qa-vcs",
            "name": "qa vcs",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "git.md",
                    "name": "git",
                    "type": "file",
                    "content": "\n[Git](https://git-scm.com/) is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\n\nVisit the following resources to learn more:\n\n- [Git & GitHub Crash Course For Beginners](https://www.youtube.com/watch?v=SWYqp7iY_Tc)\n- [Learn Git with Tutorials, News and Tips - Atlassian](https://www.atlassian.com/git)\n- [Git Cheat Sheet](https://cs.fyi/guide/git-cheatsheet)\n"
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nVersion control/source control systems allow developers to track and control changes to code over time. These services often include the ability to make atomic revisions to code, branch/fork off of specific points, and to compare versions of code. They are useful in determining the who, what, when, and why code changes were made.\n\nVisit the following resources to learn more:\n\n- [Git](https://git-scm.com/)\n- [Mercurial](https://www.mercurial-scm.org/)\n- [What is Version Control?](https://www.atlassian.com/git/tutorials/what-is-version-control)\n"
                }
            ]
        },
        {
            "id": "109",
            "fileName": "qa-repo-hosting-services",
            "name": "qa repo hosting services",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "gitlab.md",
                    "name": "gitlab",
                    "type": "file",
                    "content": "\nGitLab is a provider of internet hosting for software development and version control using Git. It offers the distributed version control and source code management functionality of Git, plus its own features.\n\nVisit the following resources to learn more:\n\n- [GitLab Website](https://gitlab.com/)\n- [GitLab Documentation](https://docs.gitlab.com/)\n"
                },
                {
                    "id": "101",
                    "fileName": "bitbucket.md",
                    "name": "bitbucket",
                    "type": "file",
                    "content": "\nBitbucket is a Git based hosting and source code repository service that is Atlassian's alternative to other products like GitHub, GitLab etc\n\nBitbucket offers hosting options via Bitbucket Cloud (Atlassian's servers), Bitbucket Server (customer's on-premise) or Bitbucket Data Centre (number of servers in customers on-premise or cloud environment)\n\nVisit the following resources to learn more:\n\n- [Bitbucket Website](https://bitbucket.org/product)\n- [A brief overview of Bitbucket](https://bitbucket.org/product/guides/getting-started/overview#a-brief-overview-of-bitbucket)\n- [Getting started with Bitbucket](https://bitbucket.org/product/guides/basics/bitbucket-interface)\n- [Using Git with Bitbucket Cloud](https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud)\n- [Bitbucket tutorial | How to use Bitbucket Cloud](https://www.youtube.com/watch?v=M44nEyd_5To)\n- [Bitbucket Tutorial | Bitbucket for Beginners](https://www.youtube.com/watch?v=i5T-DB8tb4A)\n"
                },
                {
                    "id": "102",
                    "fileName": "github.md",
                    "name": "github",
                    "type": "file",
                    "content": "\nGitHub is a provider of Internet hosting for software development and version control using Git. It offers the distributed version control and source code management functionality of Git, plus its own features.\n\nVisit the following resources to learn more:\n\n- [GitHub Website](https://github.com)\n- [GitHub Documentation](https://docs.github.com/en/get-started/quickstart)\n- [What is GitHub?](https://www.youtube.com/watch?v=w3jLJU7DT5E)\n- [Git vs. GitHub: Whats the difference?](https://www.youtube.com/watch?v=wpISo9TNjfU)\n- [Git and GitHub for Beginners](https://www.youtube.com/watch?v=RGOj5yH7evk)\n- [Git and GitHub - CS50 Beyond 2019](https://www.youtube.com/watch?v=eulnSXkhE7I)\n- [How to Use Git in a Professional Dev Team](https://ooloo.io/project/github-flow)\n"
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nThere are different repository hosting services with the most famous one being GitHub, GitLab and BitBucket. I would recommend creating an account on GitHub because that is where most of the OpenSource work is done and most of the developers are.\n\nVisit the following resources to learn more:\n\n- [GitHub: Where the world builds software](https://github.com)\n- [GitLab: Iterate faster, innovate together](https://gitlab.com)\n- [BitBucket: The Git solution for professional teams](https://bitbucket.com)\n"
                }
            ]
        },
        {
            "id": "110",
            "fileName": "qa-ci-cd",
            "name": "qa ci cd",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "jenkins.md",
                    "name": "jenkins",
                    "type": "file",
                    "content": "\nJenkins is an open-source CI/CD automation server. Jenkins is primarily used for building projects, running tests, static code analysis and deployments.\n\nVisit the following resources to learn more:\n\n- [Jenkins Website](https://www.jenkins.io/)\n- [Official Jenkins Handbook](https://www.jenkins.io/doc/book/)\n- [Jenkins Getting Started Guide](https://www.jenkins.io/doc/pipeline/tour/getting-started/)\n"
                },
                {
                    "id": "101",
                    "fileName": "travis-ci.md",
                    "name": "travis ci",
                    "type": "file",
                    "content": "\nTravis CI is a CI/CD service that is primarily used for building and testing projects that are hosted on BitBucket and GitHub. Open source projects can utilized Travis CI for free.\n\nVisit the following resources to learn more:\n\n- [Travis CI Website](https://www.travis-ci.com/)\n- [Travis CI Documentation](https://docs.travis-ci.com/)\n- [Travis CI Tutorial](https://docs.travis-ci.com/user/tutorial/)\n"
                },
                {
                    "id": "102",
                    "fileName": "circle-ci.md",
                    "name": "circle ci",
                    "type": "file",
                    "content": "\nCircleCI is a CI/CD service that can be integrated with GitHub, BitBucket and GitLab repositories. The service that can be used as a SaaS offering or self-managed using your own resources.\n\nVisit the following resources to learn more:\n\n- [CircleCI Website](https://circleci.com/)\n- [CircleCI Documentation](https://circleci.com/docs)\n- [Configuration Tutorial](https://circleci.com/docs/config-intro)\n"
                },
                {
                    "id": "103",
                    "fileName": "drone.md",
                    "name": "drone",
                    "type": "file",
                    "content": "\nDrone is a CI/CD service offering by [Harness](https://harness.io/). Each build runs on an isolated Docker container, and Drone integrates with many popular source code management repositories like GitHub, BitBucket and GitLab\n\nVisit the following resources to learn more:\n\n- [Drone Website](https://www.drone.io/)\n- [Official Documentation](https://docs.drone.io/)\n- [Drone Getting Started Guide](https://docs.drone.io/server/overview/)\n"
                },
                {
                    "id": "104",
                    "fileName": "gitlab-ci.md",
                    "name": "gitlab ci",
                    "type": "file",
                    "content": "\nGitLab offers a CI/CD service that can be used as a SaaS offering or self-managed using your own resources. You can use GitLab CI with any GitLab hosted repository, or any BitBucket Cloud or GitHub repository in the GitLab Premium self-managed, GitLab Premium SaaS and higher tiers.\n\nVisit the following resources to learn more:\n\n- [GitLab Website](https://gitlab.com/)\n- [GitLab Documentation](https://docs.gitlab.com/)\n- [Get Started with GitLab CI](https://docs.gitlab.com/ee/ci/quick_start/)\n- [Learn GitLab Tutorials](https://docs.gitlab.com/ee/tutorials/)\n- [GitLab CI/CD Examples](https://docs.gitlab.com/ee/ci/examples/)\n"
                },
                {
                    "id": "105",
                    "fileName": "bamboo.md",
                    "name": "bamboo",
                    "type": "file",
                    "content": "\nBamboo is a CI/CD service provided by Atlassian. Bamboo is primarily used for automating builds, tests and releases in a single workflow.\n\nVisit the following resources to learn more:\n\n- [Bamboo Website](https://www.atlassian.com/software/bamboo)\n- [Official Documentation](https://confluence.atlassian.com/bamboo/bamboo-documentation-289276551.html)\n- [Bamboo Getting Started Guide](https://confluence.atlassian.com/bamboo/getting-started-with-bamboo-289277283.html)\n"
                },
                {
                    "id": "106",
                    "fileName": "team-city.md",
                    "name": "team city",
                    "type": "file",
                    "content": "\nTeamCity is a CI/CD service provided by JetBrains. TeamCity can be used as a SaaS offering or self-managed using your own resources.\n\nVisit the following resources to learn more:\n\n- [TeamCity Website](https://www.jetbrains.com/teamcity/)\n- [Official Documentation](https://www.jetbrains.com/help/teamcity/teamcity-documentation.html)\n- [TeamCity Tutorials](https://www.jetbrains.com/teamcity/tutorials/)\n- [TeamCity Learning Portal](https://www.jetbrains.com/teamcity/learn/)\n"
                },
                {
                    "id": "107",
                    "fileName": "azure-devops-services.md",
                    "name": "azure devops services",
                    "type": "file",
                    "content": "\nAzure DevOps is developed by Microsoft as a full scale application lifecycle management and CI/CD service. Azure DevOps provides developer services for allowing teams to plan work, collaborate on code development, and build and deploy applications.\n\nVisit the following resources to learn more:\n\n- [Azure DevOps Website](https://azure.microsoft.com/en-us/services/devops/#overview)\n- [Official Documentation](https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops&viewFallbackFrom=vsts)\n- [Azure DevOps Getting Started Guide](https://docs.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates?view=azure-devops)\n"
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nContinuous Integration is a software development method where team members integrate their work at least once daily. An automated build checks every integration to detect errors in this method. In Continuous Integration, the software is built and tested immediately after a code commit. In a large project with many developers, commits are made many times during the day. With each commit, code is built and tested.\n\nContinuous Delivery is a software engineering method in which a team develops software products in a short cycle. It ensures that software can be easily released at any time. The main aim of continuous delivery is to build, test, and release software with good speed and frequency. It helps reduce the cost, time, and risk of delivering changes by allowing for frequent updates in production.\n\nVisit the following resources to learn more:\n\n- [What is CI/CD? Continuous Integration and Continuous Delivery](https://www.guru99.com/continuous-integration.html)\n- [Continuous Integration vs Delivery vs Deployment](https://www.guru99.com/continuous-integration-vs-delivery-vs-deployment.html)\n- [CI/CD Pipeline: Learn with Example](https://www.guru99.com/ci-cd-pipeline.html)\n"
                }
            ]
        },
        {
            "id": "111",
            "fileName": "qa-headless-testing",
            "name": "qa headless testing",
            "type": "directory",
            "children": [
                {
                    "id": "100",
                    "fileName": "zombie-js.md",
                    "name": "zombie js",
                    "type": "file",
                    "content": "\nZombie.js allows you to run Unit or Integration tests without a real web browser. Instead, it uses a simulated browser where it stores the HTML code and runs the JavaScript you may have in your HTML page. This means that an HTML page doesn’t need to be displayed, saving precious time that would otherwise be occupied rendering it.\n\nVisit the following resources to learn more:\n\n- [Zombie.js Website](http://zombie.js.org/)\n- [Getting Started with Zombie.js](https://www.packt.com/getting-started-zombiejs/)\n"
                },
                {
                    "id": "101",
                    "fileName": "playwright.md",
                    "name": "playwright",
                    "type": "file",
                    "content": "\nPlaywright is an open-source test automation library initially developed by Microsoft contributors. It supports programming languages such as Java, Python, C#, and NodeJS. Playwright comes with Apache 2.0 License and is most popular with NodeJS with Javascript/Typescript.\n\nVisit the following resources to learn more:\n\n- [Playwright Website](https://playwright.dev/)\n- [Playwright Tutorial: Learn Basics and Setup](https://www.browserstack.com/guide/playwright-tutorial)\n"
                },
                {
                    "id": "102",
                    "fileName": "puppeteer.md",
                    "name": "puppeteer",
                    "type": "file",
                    "content": "\nPuppeteer is a Node library that provides a high-level API to control headless Chrome or Chromium browsers over the DevTools Protocol. It can also be configured to use full (non-headless) Chrome or Chromium.\n\nVisit the following resources to learn more:\n\n- [Puppeteer Website](https://pptr.dev/)\n- [How to Use Puppeteer With Node.js](https://www.freecodecamp.org/news/how-to-use-puppeteer-with-nodejs/)\n"
                },
                {
                    "id": "103",
                    "fileName": "cypress.md",
                    "name": "cypress",
                    "type": "file",
                    "content": "\nCypress framework is a JavaScript-based end-to-end testing framework built on top of Mocha – a feature-rich JavaScript test framework running on and in the browser, making asynchronous testing simple and convenient. It also uses a BDD/TDD assertion library and a browser to pair with any JavaScript testing framework.\n\nVisit the following resources to learn more:\n\n- [Official Website](https://www.cypress.io/)\n- [Official Documentation](https://docs.cypress.io/guides/overview/why-cypress#Other)\n- [Cypress End-to-End Testing](https://www.youtube.com/watch?v=7N63cMKosIE)\n"
                },
                {
                    "id": "104",
                    "fileName": "headless-chrome.md",
                    "name": "headless chrome",
                    "type": "file",
                    "content": "\nHeadless Chrome is a way to run the Chrome browser in a headless environment without the full browser UI. One of the benefits of using Headless Chrome (as opposed to testing directly in Node) is that your JavaScript tests will be executed in the same environment as users of your site.\n\nVisit the following resources to learn more:\n\n- [Headless Chromium](https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md)\n"
                },
                {
                    "id": "105",
                    "fileName": "headless-fox.md",
                    "name": "headless fox",
                    "type": "file",
                    "content": "\nHeadless Browser Testing is a process of running the browser tests without the type of browser UI or GUI. In headless browser testing, to conduct cross-browser testing the tester can run test cases accurately and successfully without requiring the browser on which application needs to be tested.\n\nVisit the following resources to learn more:\n\n- [Using Headless Mode in Firefox](https://hacks.mozilla.org/2017/12/using-headless-mode-in-firefox/)\n"
                },
                {
                    "id": "106",
                    "fileName": "html-unit.md",
                    "name": "html unit",
                    "type": "file",
                    "content": "\nHtmlUnit is a \"GUI-Less browser for Java programs\". It models HTML documents and provides an API that allows you to invoke pages, fill out forms, click links, etc... just like you do in your \"normal\" browser. It has fairly good JavaScript support (which is constantly improving) and is able to work even with quite complex AJAX libraries, simulating Chrome, Firefox or Internet Explorer depending on the configuration used.\n\nHtmlUnit is not a generic unit testing framework. It is specifically a way to simulate a browser for testing purposes and is intended to be used within another testing framework such as JUnit or TestNG.\n\nVisit the following resources to learn more:\n\n- [HtmlUnit Website](https://htmlunit.sourceforge.io/)\n- [Introduction to HtmlUnit](https://www.baeldung.com/htmlunit)\n"
                },
                {
                    "fileName": "index.md",
                    "name": "index",
                    "type": "file",
                    "content": "\nHeadless testing is when end-to-end tests are performed without loading the browser's user interface. Since the browser operates as a typical browser would but does not make use of the user interface, it is considered highly suitable for automated testing.\n\nA few example cases where one may use headless browser testing include:\n\n- Automating HTML event responses, such as form submission, keyboard events, mouse-clicking, etc.\n- Web scraping\n- Generating screenshots of webpages\n\nVisit the following resources to learn more:\n\n- [What is Headless Browser Testing and Why is it Important?](https://www.browserstack.com/guide/what-is-headless-browser-testing)\n"
                }
            ]
        }
    ]
}